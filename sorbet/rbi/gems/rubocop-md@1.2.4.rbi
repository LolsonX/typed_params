# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `rubocop-md` gem.
# Please instead update this file by running `bin/tapioca gem rubocop-md`.


# source://rubocop-md//lib/rubocop/markdown/version.rb#3
module RuboCop; end

module RuboCop::AST; end

class RuboCop::AST::ProcessedSource
  # source://rubocop-ast/1.36.2/lib/rubocop/ast/processed_source.rb#28
  def initialize(source, ruby_version, path = T.unsafe(nil), parser_engine: T.unsafe(nil)); end

  # source://rubocop-ast/1.36.2/lib/rubocop/ast/processed_source.rb#72
  def [](*args); end

  # source://rubocop-ast/1.36.2/lib/rubocop/ast/processed_source.rb#20
  def ast; end

  # source://rubocop-ast/1.36.2/lib/rubocop/ast/processed_source.rb#50
  def ast_with_comments; end

  # source://rubocop-ast/1.36.2/lib/rubocop/ast/processed_source.rb#111
  def blank?; end

  # source://rubocop-ast/1.36.2/lib/rubocop/ast/processed_source.rb#20
  def buffer; end

  # source://rubocop-ast/1.36.2/lib/rubocop/ast/processed_source.rb#83
  def checksum; end

  # source://rubocop-ast/1.36.2/lib/rubocop/ast/processed_source.rb#116
  def comment_at_line(line); end

  # source://rubocop-ast/1.36.2/lib/rubocop/ast/processed_source.rb#138
  def commented?(source_range); end

  # source://rubocop-ast/1.36.2/lib/rubocop/ast/processed_source.rb#20
  def comments; end

  # source://rubocop-ast/1.36.2/lib/rubocop/ast/processed_source.rb#146
  def comments_before_line(line); end

  # source://rubocop-ast/1.36.2/lib/rubocop/ast/processed_source.rb#138
  def contains_comment?(source_range); end

  # source://rubocop-ast/1.36.2/lib/rubocop/ast/processed_source.rb#160
  def current_line(token); end

  # source://rubocop-ast/1.36.2/lib/rubocop/ast/processed_source.rb#20
  def diagnostics; end

  # source://rubocop-ast/1.36.2/lib/rubocop/ast/processed_source.rb#88
  def each_comment(&block); end

  # source://rubocop-ast/1.36.2/lib/rubocop/ast/processed_source.rb#126
  def each_comment_in_lines(line_range); end

  # source://rubocop-ast/1.36.2/lib/rubocop/ast/processed_source.rb#98
  def each_token(&block); end

  # source://rubocop-ast/1.36.2/lib/rubocop/ast/processed_source.rb#107
  def file_path; end

  # source://rubocop-ast/1.36.2/lib/rubocop/ast/processed_source.rb#93
  def find_comment(&block); end

  # source://rubocop-ast/1.36.2/lib/rubocop/ast/processed_source.rb#103
  def find_token(&block); end

  # source://rubocop-ast/1.36.2/lib/rubocop/ast/processed_source.rb#181
  def first_token_of(range_or_node); end

  # source://rubocop-ast/1.36.2/lib/rubocop/ast/processed_source.rb#164
  def following_line(token); end

  # source://rubocop-ast/1.36.2/lib/rubocop/ast/processed_source.rb#185
  def last_token_of(range_or_node); end

  # source://rubocop-ast/1.36.2/lib/rubocop/ast/processed_source.rb#168
  def line_indentation(line_number); end

  # source://rubocop-ast/1.36.2/lib/rubocop/ast/processed_source.rb#121
  def line_with_comment?(line); end

  # source://rubocop-ast/1.36.2/lib/rubocop/ast/processed_source.rb#58
  def lines; end

  # source://rubocop-md//lib/rubocop/markdown/rubocop_ext.rb#98
  def parse(src, *args); end

  # source://rubocop-ast/1.36.2/lib/rubocop/ast/processed_source.rb#20
  def parser_engine; end

  # source://rubocop-ast/1.36.2/lib/rubocop/ast/processed_source.rb#20
  def parser_error; end

  # source://rubocop-ast/1.36.2/lib/rubocop/ast/processed_source.rb#20
  def path; end

  # source://rubocop-ast/1.36.2/lib/rubocop/ast/processed_source.rb#156
  def preceding_line(token); end

  # source://rubocop-ast/1.36.2/lib/rubocop/ast/processed_source.rb#20
  def raw_source; end

  # source://rubocop-ast/1.36.2/lib/rubocop/ast/processed_source.rb#20
  def ruby_version; end

  # source://rubocop-ast/1.36.2/lib/rubocop/ast/processed_source.rb#192
  def sorted_tokens; end

  # source://rubocop-ast/1.36.2/lib/rubocop/ast/processed_source.rb#150
  def start_with?(string); end

  # source://rubocop-ast/1.36.2/lib/rubocop/ast/processed_source.rb#20
  def tokens; end

  # source://rubocop-ast/1.36.2/lib/rubocop/ast/processed_source.rb#175
  def tokens_within(range_or_node); end

  # source://rubocop-ast/1.36.2/lib/rubocop/ast/processed_source.rb#76
  def valid_syntax?; end

  private

  # source://rubocop-ast/1.36.2/lib/rubocop/ast/processed_source.rb#199
  def comment_index; end

  # source://rubocop-ast/1.36.2/lib/rubocop/ast/processed_source.rb#309
  def create_parser(ruby_version, parser_engine); end

  # source://rubocop-ast/1.36.2/lib/rubocop/ast/processed_source.rb#325
  def first_token_index(range_or_node); end

  # source://rubocop-ast/1.36.2/lib/rubocop/ast/processed_source.rb#330
  def last_token_index(range_or_node); end

  # source://rubocop-ast/1.36.2/lib/rubocop/ast/processed_source.rb#238
  def parser_class(ruby_version, parser_engine); end

  # source://rubocop-ast/1.36.2/lib/rubocop/ast/processed_source.rb#335
  def source_range(range_or_node); end

  # source://rubocop-ast/1.36.2/lib/rubocop/ast/processed_source.rb#222
  def tokenize(parser); end

  class << self
    # source://rubocop-ast/1.36.2/lib/rubocop/ast/processed_source.rb#23
    def from_file(path, ruby_version, parser_engine: T.unsafe(nil)); end
  end
end

# Plugin to run Rubocop against Markdown files
#
# source://rubocop-md//lib/rubocop/markdown/version.rb#4
module RuboCop::Markdown
  class << self
    # Returns the value of attribute config_store.
    #
    # source://rubocop-md//lib/rubocop/markdown/rubocop_ext.rb#25
    def config_store; end

    # Sets the attribute config_store
    #
    # @param value the value to set the attribute config_store to.
    #
    # source://rubocop-md//lib/rubocop/markdown/rubocop_ext.rb#25
    def config_store=(_arg0); end

    # Merge markdown config into default configuration
    # See https://github.com/backus/rubocop-rspec/blob/master/lib/rubocop/rspec/inject.rb
    #
    # source://rubocop-md//lib/rubocop/markdown/rubocop_ext.rb#29
    def inject!; end

    # @return [Boolean]
    #
    # source://rubocop-md//lib/rubocop/markdown/rubocop_ext.rb#38
    def markdown_file?(file); end
  end
end

# source://rubocop-md//lib/rubocop/markdown.rb#10
RuboCop::Markdown::CONFIG_DEFAULT = T.let(T.unsafe(nil), Pathname)

# See https://github.com/github-linguist/linguist/blob/8c380f360ce00b95fa08d14ce0ebccd481af1b33/lib/linguist/languages.yml#L4088-L4098
# Keep in sync with config/default.yml
#
# source://rubocop-md//lib/rubocop/markdown/rubocop_ext.rb#7
RuboCop::Markdown::MARKDOWN_EXTENSIONS = T.let(T.unsafe(nil), Array)

# A list of cops that could produce offenses in commented lines
#
# source://rubocop-md//lib/rubocop/markdown/rubocop_ext.rb#22
RuboCop::Markdown::MARKDOWN_OFFENSE_COPS = T.let(T.unsafe(nil), Array)

# source://rubocop-md//lib/rubocop/markdown.rb#9
RuboCop::Markdown::PROJECT_ROOT = T.let(T.unsafe(nil), Pathname)

# Transform source Markdown file into valid Ruby file
# by commenting out all non-code lines
#
# source://rubocop-md//lib/rubocop/markdown/preprocess.rb#9
class RuboCop::Markdown::Preprocess
  # @return [Preprocess] a new instance of Preprocess
  #
  # source://rubocop-md//lib/rubocop/markdown/preprocess.rb#55
  def initialize(file); end

  # source://rubocop-md//lib/rubocop/markdown/preprocess.rb#60
  def call(src); end

  # Returns the value of attribute config.
  #
  # source://rubocop-md//lib/rubocop/markdown/preprocess.rb#53
  def config; end

  private

  # Whether to try to detect Ruby by parsing codeblock.
  # If it's set to false we lint only implicitly specified Ruby blocks.
  #
  # @return [Boolean]
  #
  # source://rubocop-md//lib/rubocop/markdown/preprocess.rb#116
  def autodetect?; end

  # source://rubocop-md//lib/rubocop/markdown/preprocess.rb#120
  def comment_lines(src); end

  # Check codeblock attribute to prevent from parsing
  # non-Ruby snippets and avoid false positives
  #
  # @return [Boolean]
  #
  # source://rubocop-md//lib/rubocop/markdown/preprocess.rb#91
  def maybe_ruby?(syntax); end

  # Check codeblack attribute if it's defined and of Ruby type
  #
  # @return [Boolean]
  #
  # source://rubocop-md//lib/rubocop/markdown/preprocess.rb#96
  def ruby?(syntax); end

  # @return [Boolean]
  #
  # source://rubocop-md//lib/rubocop/markdown/preprocess.rb#85
  def ruby_codeblock?(syntax, src); end

  # Try to parse with Ripper
  # Invalid Ruby code (or non-Ruby) returns `nil`.
  # Return true if it's explicit Ruby and warn_invalid?
  #
  # @return [Boolean]
  #
  # source://rubocop-md//lib/rubocop/markdown/preprocess.rb#103
  def valid_syntax?(syntax, src); end

  # Whether to show warning when snippet is not a valid Ruby
  #
  # @return [Boolean]
  #
  # source://rubocop-md//lib/rubocop/markdown/preprocess.rb#110
  def warn_invalid?; end

  class << self
    # source://rubocop-md//lib/rubocop/markdown/preprocess.rb#48
    def restore!(src); end

    # Revert preprocess changes.
    #
    # When autocorrect is applied, RuboCop re-writes the file
    # using preproccessed source buffer.
    #
    # We have to restore it.
    #
    # source://rubocop-md//lib/rubocop/markdown/preprocess.rb#42
    def restore_and_save!(file); end
  end
end

# source://rubocop-md//lib/rubocop/markdown/preprocess.rb#23
RuboCop::Markdown::Preprocess::MARKER = T.let(T.unsafe(nil), String)

# This is a regexp to parse code blocks from .md files.
#
# Only recognizes backticks-style code blocks.
#
# Try it: https://rubular.com/r/YMqSWiBuh2TKIJ
#
# source://rubocop-md//lib/rubocop/markdown/preprocess.rb#15
RuboCop::Markdown::Preprocess::MD_REGEXP = T.let(T.unsafe(nil), Regexp)

# See https://github.com/github/linguist/blob/v5.3.3/lib/linguist/languages.yml#L3925
#
# source://rubocop-md//lib/rubocop/markdown/preprocess.rb#26
RuboCop::Markdown::Preprocess::RUBY_TYPES = T.let(T.unsafe(nil), Array)

# source://rubocop-md//lib/rubocop/markdown/version.rb#5
RuboCop::Markdown::VERSION = T.let(T.unsafe(nil), String)

class RuboCop::Runner
  # source://rubocop/1.69.0/lib/rubocop/runner.rb#63
  def initialize(options, config_store); end

  # source://rubocop/1.69.0/lib/rubocop/runner.rb#61
  def aborting=(_arg0); end

  # source://rubocop/1.69.0/lib/rubocop/runner.rb#87
  def aborting?; end

  # source://rubocop/1.69.0/lib/rubocop/runner.rb#60
  def errors; end

  # source://rubocop-md//lib/rubocop/markdown/rubocop_ext.rb#63
  def file_finished(file, offenses); end

  # source://rubocop-md//lib/rubocop/markdown/rubocop_ext.rb#57
  def file_offense_cache(file); end

  # source://rubocop-md//lib/rubocop/markdown/rubocop_ext.rb#49
  def get_processed_source(*args); end

  # source://rubocop/1.69.0/lib/rubocop/runner.rb#71
  def run(paths); end

  # source://rubocop/1.69.0/lib/rubocop/runner.rb#60
  def warnings; end

  private

  # source://rubocop/1.69.0/lib/rubocop/runner.rb#200
  def add_redundant_disables(file, offenses, source); end

  # source://rubocop/1.69.0/lib/rubocop/runner.rb#174
  def cached_result(file, team); end

  # source://rubocop/1.69.0/lib/rubocop/runner.rb#254
  def cached_run?; end

  # source://rubocop/1.69.0/lib/rubocop/runner.rb#332
  def check_for_infinite_loop(processed_source, offenses_by_iteration); end

  # source://rubocop/1.69.0/lib/rubocop/runner.rb#226
  def check_for_redundant_disables?(source); end

  # source://rubocop/1.69.0/lib/rubocop/runner.rb#434
  def considered_failure?(offense); end

  # source://rubocop/1.69.0/lib/rubocop/runner.rb#471
  def default_config(cop_name); end

  # source://rubocop/1.69.0/lib/rubocop/runner.rb#276
  def do_inspection_loop(file); end

  # source://rubocop/1.69.0/lib/rubocop/runner.rb#137
  def each_inspected_file(files); end

  # source://rubocop/1.69.0/lib/rubocop/runner.rb#240
  def except_redundant_cop_disable_directive?; end

  # source://rubocop/1.69.0/lib/rubocop/runner.rb#361
  def extract_ruby_sources(processed_source); end

  # source://rubocop/1.69.0/lib/rubocop/runner.rb#166
  def file_offenses(file); end

  # source://rubocop/1.69.0/lib/rubocop/runner.rb#244
  def file_started(file); end

  # source://rubocop/1.69.0/lib/rubocop/runner.rb#414
  def filter_cop_classes(cop_classes, config); end

  # source://rubocop/1.69.0/lib/rubocop/runner.rb#108
  def find_target_files(paths); end

  # source://rubocop/1.69.0/lib/rubocop/runner.rb#425
  def formatter_set; end

  # source://rubocop/1.69.0/lib/rubocop/runner.rb#346
  def inspect_file(processed_source, team = T.unsafe(nil)); end

  # source://rubocop/1.69.0/lib/rubocop/runner.rb#119
  def inspect_files(files); end

  # source://rubocop/1.69.0/lib/rubocop/runner.rb#307
  def iterate_until_no_changes(source, offenses_by_iteration); end

  # source://rubocop/1.69.0/lib/rubocop/runner.rb#152
  def list_files(paths); end

  # source://rubocop/1.69.0/lib/rubocop/runner.rb#467
  def mark_as_safe_by_config?(config); end

  # source://rubocop/1.69.0/lib/rubocop/runner.rb#475
  def minimum_severity_to_fail; end

  # source://rubocop/1.69.0/lib/rubocop/runner.rb#375
  def mobilize_team(processed_source); end

  # source://rubocop/1.69.0/lib/rubocop/runner.rb#380
  def mobilized_cop_classes(config); end

  # source://rubocop/1.69.0/lib/rubocop/runner.rb#443
  def offense_displayed?(offense); end

  # source://rubocop/1.69.0/lib/rubocop/runner.rb#455
  def offenses_to_report(offenses); end

  # source://rubocop/1.69.0/lib/rubocop/runner.rb#156
  def process_file(file); end

  # source://rubocop/1.69.0/lib/rubocop/runner.rb#404
  def qualify_option_cop_names; end

  # source://rubocop/1.69.0/lib/rubocop/runner.rb#232
  def redundant_cop_disable_directive(file); end

  # source://rubocop/1.69.0/lib/rubocop/runner.rb#266
  def save_in_cache(cache, offenses); end

  # source://rubocop/1.69.0/lib/rubocop/runner.rb#514
  def standby_team(config); end

  # source://rubocop/1.69.0/lib/rubocop/runner.rb#421
  def style_guide_cops_only?(config); end

  # source://rubocop/1.69.0/lib/rubocop/runner.rb#459
  def supports_safe_autocorrect?(offense); end

  # source://rubocop/1.69.0/lib/rubocop/runner.rb#215
  def team_for_redundant_disables(file, offenses, source); end

  # source://rubocop/1.69.0/lib/rubocop/runner.rb#95
  def warm_cache(target_files); end

  class << self
    # source://rubocop/1.69.0/lib/rubocop/runner.rb#33
    def ruby_extractors; end

    private

    # source://rubocop/1.69.0/lib/rubocop/runner.rb#40
    def default_ruby_extractor; end
  end
end

class RuboCop::TargetFinder
  # source://rubocop/1.69.0/lib/rubocop/target_finder.rb#9
  def initialize(config_store, options = T.unsafe(nil)); end

  # source://rubocop/1.69.0/lib/rubocop/target_finder.rb#17
  def find(args, mode); end

  # source://rubocop/1.69.0/lib/rubocop/target_finder.rb#58
  def find_files(base_dir, flags); end

  # source://rubocop-md//lib/rubocop/markdown/rubocop_ext.rb#91
  def ruby_file?(file); end

  # source://rubocop/1.69.0/lib/rubocop/target_finder.rb#41
  def target_files_in_dir(base_dir = T.unsafe(nil)); end

  private

  # source://rubocop/1.69.0/lib/rubocop/target_finder.rb#120
  def all_cops_include; end

  # source://rubocop/1.69.0/lib/rubocop/target_finder.rb#106
  def combined_exclude_glob_patterns(base_dir); end

  # source://rubocop/1.69.0/lib/rubocop/target_finder.rb#172
  def configured_include?(file); end

  # source://rubocop/1.69.0/lib/rubocop/target_finder.rb#208
  def debug?; end

  # source://rubocop/1.69.0/lib/rubocop/target_finder.rb#212
  def fail_fast?; end

  # source://rubocop/1.69.0/lib/rubocop/target_finder.rb#200
  def force_exclusion?; end

  # source://rubocop/1.69.0/lib/rubocop/target_finder.rb#204
  def ignore_parent_exclusion?; end

  # source://rubocop/1.69.0/lib/rubocop/target_finder.rb#145
  def included_file?(file); end

  # source://rubocop/1.69.0/lib/rubocop/target_finder.rb#191
  def order; end

  # source://rubocop/1.69.0/lib/rubocop/target_finder.rb#124
  def process_explicit_path(path, mode); end

  # source://rubocop/1.69.0/lib/rubocop/target_finder.rb#176
  def ruby_executable?(file); end

  # source://rubocop/1.69.0/lib/rubocop/target_finder.rb#157
  def ruby_extension?(file); end

  # source://rubocop/1.69.0/lib/rubocop/target_finder.rb#161
  def ruby_extensions; end

  # source://rubocop/1.69.0/lib/rubocop/target_finder.rb#168
  def ruby_filename?(file); end

  # source://rubocop/1.69.0/lib/rubocop/target_finder.rb#113
  def ruby_filenames; end

  # source://rubocop/1.69.0/lib/rubocop/target_finder.rb#187
  def ruby_interpreters(file); end

  # source://rubocop/1.69.0/lib/rubocop/target_finder.rb#153
  def stdin?; end

  # source://rubocop/1.69.0/lib/rubocop/target_finder.rb#98
  def symlink_excluded_or_infinite_loop?(base_dir, current_dir, exclude_pattern, flags); end

  # source://rubocop/1.69.0/lib/rubocop/target_finder.rb#73
  def to_inspect?(file, hidden_files, base_dir_config); end

  # source://rubocop/1.69.0/lib/rubocop/target_finder.rb#82
  def wanted_dir_patterns(base_dir, exclude_pattern, flags); end

  # source://rubocop/1.69.0/lib/rubocop/target_finder.rb#134
  def without_excluded(files); end
end
